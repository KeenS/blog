---
title: "多倍長整数の実装1（C/C++）"
emoji: "🧮"
type: "tech"
topics: ["int","add", "C++"]
published: false
---
## 初めに

これからしばらくC/C++による多倍長整数演算の実装を解説します。
主なターゲットはx64ですがAarch64やWebAssembly（Wasm）なども考慮します。
利用目的が楕円曲線やペアリングを使った暗号なので、ビット長は256～512ビットの固定長とします。
それよりも長いビット長や可変長なものは扱いません。

## 多倍長整数の表現

現在のC++(20)では`uint64_t`より大きい整数の型はありません。
そこでより大きい整数は自分で実装する必要があります。

`Unit`をCPUの汎用レジスタのサイズ（64ビット or 32ビット）に合わせて`uint64_t`か`uint32_t`とします。
いくつか記号を準備します。

- `UnitBitSize`を`sizeof(Unit) * 8`（= 64 or 32）
- `M = 1 << UnitBitSize`

符号無し多倍長整数を`Unit`の配列で表現します。
たとえば64ビットCPUなら`Unit = uint64_t`なので256ビット整数は256 / 64 = 4個の配列です。

```
Unit x[4];
```

ここでは配列の小さい添え字が下位の値を表現すると決めます。
たとえば`x[4] = { 1, 2, 3, 4 };`とすると、この`x`は

```
x = (4 << 192) | (3 << 128) | (2 << 64) | (1 << 0) = 0x4000000000000000300000000000000020000000000000001
```
という値を意味します。
同様に`[a:b:c:d]`と書くと、断りがない限り`a`, `b`, `c`, `d`はそれぞれ`Unit`のサイズで
全体で`(a << (UnitBitSize * 3)) | (b << (UnitBitSize * 2)) | (c << UnitBitSize) | d`を意味します。

## 加算

多倍長整数同士の加算から始めます。

たとえば10進数の25+67を筆算で計算すると、

```
  2 5
+ 6 7
-----
  1 2
  8
-----
  9 2
```

となります。1桁目の`5 + 7`は1繰り上がって2桁目の`2 + 6`に`+1`します。

Unitを使う場合は64（32）ビット進数となりますが、計算結果がM（= `1 << UnitBitSize`）を越えるとMで割ったあまりになるので繰り上がりが無くなります。
